// Code generated by entc, DO NOT EDIT.

package http

import (
	"net/http"
	"strconv"

	"github.com/go-chi/chi/v5"
	easyjson "github.com/mailru/easyjson"
	"github.com/masseelch/elk/internal/integration/pets/ent"
	"github.com/masseelch/elk/internal/integration/pets/ent/badge"
	pet "github.com/masseelch/elk/internal/integration/pets/ent/pet"
	playgroup "github.com/masseelch/elk/internal/integration/pets/ent/playgroup"
	"github.com/masseelch/elk/internal/integration/pets/ent/toy"
	"github.com/masseelch/render"
	"go.uber.org/zap"
)

// Update updates a given ent.Badge and saves the changes to the database.
func (h BadgeHandler) Update(w http.ResponseWriter, r *http.Request) {
	l := h.log.With(zap.String("method", "Update"))
	// ID is URL parameter.
	id, err := strconv.Atoi(chi.URLParam(r, "id"))
	if err != nil {
		l.Error("error getting id from url parameter", zap.String("id", chi.URLParam(r, "id")), zap.Error(err))
		render.BadRequest(w, r, "id must be an integer greater zero")
		return
	}
	// Get the post data.
	var d BadgeUpdateRequest
	if err := easyjson.UnmarshalFromReader(r.Body, &d); err != nil {
		l.Error("error decoding json", zap.Error(err))
		render.BadRequest(w, r, "invalid json string")
		return
	}
	// Save the data.
	b := h.client.Badge.UpdateOneID(id)
	if d.Wearer != nil {
		b.SetWearerID(*d.Wearer)

	}
	// Store in database.
	e, err := b.Save(r.Context())
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			msg := stripEntError(err)
			l.Info(msg, zap.Error(err), zap.Int("id", id))
			render.NotFound(w, r, msg)
		case ent.IsNotSingular(err):
			msg := stripEntError(err)
			l.Error(msg, zap.Error(err), zap.Int("id", id))
			render.BadRequest(w, r, msg)
		default:
			l.Error("could-not-update-badge", zap.Error(err), zap.Int("id", id))
			render.InternalServerError(w, r, nil)
		}
		return
	}
	// Reload entry.
	q := h.client.Badge.Query().Where(badge.ID(e.ID))
	e, err = q.Only(r.Context())
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			msg := stripEntError(err)
			l.Info(msg, zap.Error(err), zap.Int("id", id))
			render.NotFound(w, r, msg)
		case ent.IsNotSingular(err):
			msg := stripEntError(err)
			l.Error(msg, zap.Error(err), zap.Int("id", id))
			render.BadRequest(w, r, msg)
		default:
			l.Error("could-not-read-badge", zap.Error(err), zap.Int("id", id))
			render.InternalServerError(w, r, nil)
		}
		return
	}
	l.Info("badge rendered", zap.Int("id", e.ID))
	easyjson.MarshalToHTTPResponseWriter(NewBadgeUpdateResponse(e), w)
}

// Update updates a given ent.Pet and saves the changes to the database.
func (h PetHandler) Update(w http.ResponseWriter, r *http.Request) {
	l := h.log.With(zap.String("method", "Update"))
	// ID is URL parameter.
	id, err := strconv.Atoi(chi.URLParam(r, "id"))
	if err != nil {
		l.Error("error getting id from url parameter", zap.String("id", chi.URLParam(r, "id")), zap.Error(err))
		render.BadRequest(w, r, "id must be an integer greater zero")
		return
	}
	// Get the post data.
	var d PetUpdateRequest
	if err := easyjson.UnmarshalFromReader(r.Body, &d); err != nil {
		l.Error("error decoding json", zap.Error(err))
		render.BadRequest(w, r, "invalid json string")
		return
	}
	// Save the data.
	b := h.client.Pet.UpdateOneID(id)
	if d.Height != nil {
		b.SetHeight(*d.Height)
	}
	if d.Weight != nil {
		b.SetWeight(*d.Weight)
	}
	if d.Castrated != nil {
		b.SetCastrated(*d.Castrated)
	}
	if d.Name != nil {
		b.SetName(*d.Name)
	}
	if d.Birthday != nil {
		b.SetBirthday(*d.Birthday)
	}
	if d.Nicknames != nil {
		b.SetNicknames(*d.Nicknames)
	}
	if d.Sex != nil {
		b.SetSex(*d.Sex)
	}
	if d.Chip != nil {
		b.SetChip(*d.Chip)
	}
	if d.Badge != nil {
		b.SetBadgeID(*d.Badge)

	}
	if d.Protege != nil {
		b.SetProtegeID(*d.Protege)

	}
	if d.Mentor != nil {
		b.SetMentorID(*d.Mentor)

	}
	if d.Spouse != nil {
		b.SetSpouseID(*d.Spouse)

	}
	if d.Toys != nil {
		b.ClearToys().AddToyIDs(d.Toys...)
	}
	if d.Parent != nil {
		b.SetParentID(*d.Parent)

	}
	if d.Children != nil {
		b.ClearChildren().AddChildIDs(d.Children...)
	}
	if d.PlayGroups != nil {
		b.ClearPlayGroups().AddPlayGroupIDs(d.PlayGroups...)
	}
	if d.Friends != nil {
		b.ClearFriends().AddFriendIDs(d.Friends...)
	}
	// Store in database.
	e, err := b.Save(r.Context())
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			msg := stripEntError(err)
			l.Info(msg, zap.Error(err), zap.Int("id", id))
			render.NotFound(w, r, msg)
		case ent.IsNotSingular(err):
			msg := stripEntError(err)
			l.Error(msg, zap.Error(err), zap.Int("id", id))
			render.BadRequest(w, r, msg)
		default:
			l.Error("could-not-update-pet", zap.Error(err), zap.Int("id", id))
			render.InternalServerError(w, r, nil)
		}
		return
	}
	// Reload entry.
	q := h.client.Pet.Query().Where(pet.ID(e.ID))
	e, err = q.Only(r.Context())
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			msg := stripEntError(err)
			l.Info(msg, zap.Error(err), zap.Int("id", id))
			render.NotFound(w, r, msg)
		case ent.IsNotSingular(err):
			msg := stripEntError(err)
			l.Error(msg, zap.Error(err), zap.Int("id", id))
			render.BadRequest(w, r, msg)
		default:
			l.Error("could-not-read-pet", zap.Error(err), zap.Int("id", id))
			render.InternalServerError(w, r, nil)
		}
		return
	}
	l.Info("pet rendered", zap.Int("id", e.ID))
	easyjson.MarshalToHTTPResponseWriter(NewPetUpdateResponse(e), w)
}

// Update updates a given ent.PlayGroup and saves the changes to the database.
func (h PlayGroupHandler) Update(w http.ResponseWriter, r *http.Request) {
	l := h.log.With(zap.String("method", "Update"))
	// ID is URL parameter.
	id, err := strconv.Atoi(chi.URLParam(r, "id"))
	if err != nil {
		l.Error("error getting id from url parameter", zap.String("id", chi.URLParam(r, "id")), zap.Error(err))
		render.BadRequest(w, r, "id must be an integer greater zero")
		return
	}
	// Get the post data.
	var d PlayGroupUpdateRequest
	if err := easyjson.UnmarshalFromReader(r.Body, &d); err != nil {
		l.Error("error decoding json", zap.Error(err))
		render.BadRequest(w, r, "invalid json string")
		return
	}
	// Save the data.
	b := h.client.PlayGroup.UpdateOneID(id)
	if d.Title != nil {
		b.SetTitle(*d.Title)
	}
	if d.Description != nil {
		b.SetDescription(*d.Description)
	}
	if d.Weekday != nil {
		b.SetWeekday(*d.Weekday)
	}
	if d.Participants != nil {
		b.ClearParticipants().AddParticipantIDs(d.Participants...)
	}
	// Store in database.
	e, err := b.Save(r.Context())
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			msg := stripEntError(err)
			l.Info(msg, zap.Error(err), zap.Int("id", id))
			render.NotFound(w, r, msg)
		case ent.IsNotSingular(err):
			msg := stripEntError(err)
			l.Error(msg, zap.Error(err), zap.Int("id", id))
			render.BadRequest(w, r, msg)
		default:
			l.Error("could-not-update-play-group", zap.Error(err), zap.Int("id", id))
			render.InternalServerError(w, r, nil)
		}
		return
	}
	// Reload entry.
	q := h.client.PlayGroup.Query().Where(playgroup.ID(e.ID))
	e, err = q.Only(r.Context())
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			msg := stripEntError(err)
			l.Info(msg, zap.Error(err), zap.Int("id", id))
			render.NotFound(w, r, msg)
		case ent.IsNotSingular(err):
			msg := stripEntError(err)
			l.Error(msg, zap.Error(err), zap.Int("id", id))
			render.BadRequest(w, r, msg)
		default:
			l.Error("could-not-read-play-group", zap.Error(err), zap.Int("id", id))
			render.InternalServerError(w, r, nil)
		}
		return
	}
	l.Info("play-group rendered", zap.Int("id", e.ID))
	easyjson.MarshalToHTTPResponseWriter(NewPlayGroupUpdateResponse(e), w)
}

// Update updates a given ent.Toy and saves the changes to the database.
func (h ToyHandler) Update(w http.ResponseWriter, r *http.Request) {
	l := h.log.With(zap.String("method", "Update"))
	// ID is URL parameter.
	id, err := strconv.Atoi(chi.URLParam(r, "id"))
	if err != nil {
		l.Error("error getting id from url parameter", zap.String("id", chi.URLParam(r, "id")), zap.Error(err))
		render.BadRequest(w, r, "id must be an integer greater zero")
		return
	}
	// Get the post data.
	var d ToyUpdateRequest
	if err := easyjson.UnmarshalFromReader(r.Body, &d); err != nil {
		l.Error("error decoding json", zap.Error(err))
		render.BadRequest(w, r, "invalid json string")
		return
	}
	// Save the data.
	b := h.client.Toy.UpdateOneID(id)
	if d.Title != nil {
		b.SetTitle(*d.Title)
	}
	if d.Owner != nil {
		b.SetOwnerID(*d.Owner)

	}
	// Store in database.
	e, err := b.Save(r.Context())
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			msg := stripEntError(err)
			l.Info(msg, zap.Error(err), zap.Int("id", id))
			render.NotFound(w, r, msg)
		case ent.IsNotSingular(err):
			msg := stripEntError(err)
			l.Error(msg, zap.Error(err), zap.Int("id", id))
			render.BadRequest(w, r, msg)
		default:
			l.Error("could-not-update-toy", zap.Error(err), zap.Int("id", id))
			render.InternalServerError(w, r, nil)
		}
		return
	}
	// Reload entry.
	q := h.client.Toy.Query().Where(toy.ID(e.ID))
	e, err = q.Only(r.Context())
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			msg := stripEntError(err)
			l.Info(msg, zap.Error(err), zap.Int("id", id))
			render.NotFound(w, r, msg)
		case ent.IsNotSingular(err):
			msg := stripEntError(err)
			l.Error(msg, zap.Error(err), zap.Int("id", id))
			render.BadRequest(w, r, msg)
		default:
			l.Error("could-not-read-toy", zap.Error(err), zap.Int("id", id))
			render.InternalServerError(w, r, nil)
		}
		return
	}
	l.Info("toy rendered", zap.Int("id", e.ID))
	easyjson.MarshalToHTTPResponseWriter(NewToyUpdateResponse(e), w)
}
